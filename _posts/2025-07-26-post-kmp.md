---
title: "Post:KMP"
date: 2025-07-26T11:19:00+08:00
categories: 
  - blog
tags:
  - study 
---

一·算法简介

1.简介：一种高效字符串匹配算法，通过预处理模式串生成next数组（部分匹配表），在匹配失败时跳过无效比较，将时间复杂度优化至O(n+m)（n为主串长度，m为模式串长度）

2.next数组
- 定义​：next[i]表示模式串P[0..i]中，​最长相等真前缀和真后缀的长度​（不包括子串本身）
- 作用​：当匹配失败时，根据next值移动模式串指针，避免主串回溯
- 构建逻辑
    - P[0]：无前缀/后缀，next[0]=0
    - P[1..8]：若P[i] == P[j]，则j++；否则j = next[j-1]回退


二·经典例题

1.
# P3375 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 输入格式

第一行为一个字符串，即为 $s_1$。  
第二行为一个字符串，即为 $s_2$。

## 输出格式

首先输出若干行，每行一个整数，**按从小到大的顺序**输出 $s_2$ 在 $s_1$ 中出现的位置。  
最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。

## 输入输出样例 #1

### 输入 #1

```
ABABABC
ABA
```

### 输出 #1

```
1
3
0 0 1
```

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 0（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 1（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 2（30 points）：无特殊约定。
- Subtask 3（0 points）：Hack。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。


解：
```cpp
#include<iostream>

using namespace std;

int main(){

    return 0;
}
```